---
/* Render a button to engage focused mode
 * Focused mode does two things
 * - temporarily closes the sidebar
 * - lower the opacity of the pageTableOfContents
*/
import ProfileButton from "@components/user/ProfileButton.astro";

const currentPathname = Astro.url.pathname;

// Allowed paths to show the focused mode button
const isAllowedPathname = currentPathname.startsWith("/year1") || currentPathname.startsWith("/year2");;
---
{ isAllowedPathname ?
  <focused-mode>
    <ProfileButton icon="open-book">Focused Mode</ProfileButton>
  </focused-mode>
: ""
}

<style>

</style>

<script>
class FocusedMode extends HTMLElement {
  focusedButton = this.querySelector('button') as HTMLButtonElement;
  TABLET_WIDTH = 1152;
  sidebar = document.getElementById("starlight__sidebar") as HTMLDivElement;
  toc = document.querySelector(".right-sidebar") as HTMLDivElement;
  theme = document.documentElement.dataset.theme;
  starlightButton = this.querySelector("starlight-menu-button");
  isPC = window.innerWidth >= this.TABLET_WIDTH; // Check: Greater that a tablet

  /* For order of operations, since using focusedMode, which we would have initialized
   * in the constructor would have called the setter */
  private _focusedModeInternal = false;

  constructor() {
    super();

    this._focusedModeInternal = sessionStorage.getItem("focused-mode") === "1";

    if (this._focusedModeInternal) {
      // intial styles if focused mode was active
      this._applyInitialStyles();
    }
  }

  // Apply styles without animation for initial styles if focused mode was on
  private _applyInitialStyles() {
    this.sidebar.style.opacity = "0";
    this.sidebar.style.transform = "translateX(-400px)";
    
    if (this.isPC && this.toc) {
      this.toc.style.opacity = ".2";
      this.toc.style.border = "none";
    }
  }

  // Using arrow function to preserve 'this'
  private handleResize = () => {
    this.isPC = window.innerWidth >= this.TABLET_WIDTH;

    // Re-evaluate TOC visibility if focused mode is active
    if (this.focusedMode) {
      if (this.isPC && this.toc) {
        // If hover is active during resize
        const isHoveringTOC = this.toc.matches(":hover");
        this.toc.style.opacity = isHoveringTOC? "1": ".2";
        this.toc.style.border = "none";
      } else {
        // TOC was styles for PC, reset it
        if (this.toc) {
          this.toc.style.opacity = "1";
          this.toc.style.borderInlineStart = "1px solid var(--sl-color-hairline)";
        }
      }
    }
  }

  get focusedMode() {
    return this._focusedModeInternal;
  }

  set focusedMode(value: boolean) {
    this._focusedModeInternal = value;
    sessionStorage.setItem("focused-mode", value ? "1" : "0");
  }

  activate() {
    this.focusedMode = true;
    
    this.sidebar.animate([
      { opacity: 1, transform: "translateX(0)"}, // from
      { opacity: 0, transform: "translateX(-400px)"}, // to
    ], {
        duration: 300,
        easing: 'ease-out'
      });

    this.sidebar.style.opacity = "0";

    // Table of contents
    if (this.isPC) {
      this.toc.animate([
        { opacity: 1}, // from 
        { opacity: .2} // to
      ], {
          duration: 300,
          easing: "ease-out"
        });
      this.toc.style.opacity = ".2";
      this.toc.style.border = "none";
    }
  }

  deactivate() {
    this.focusedMode = false;

    this.sidebar.animate([
      { opacity: 0, transform: "translateX(-400px)"}, // from
      { opacity: 1, transform: "translateX(0)"}, // to
    ], {
        duration: 150,
        easing: 'ease-in',
    });

    this.sidebar.style.opacity = "1";
    this.sidebar.style.transform = "translateX(0)";

    // Table of contents
    if (this.isPC) {
      this.toc.animate([
        { opacity: .2}, // from 
        { opacity: 1} // to
      ], {
          duration: 150,
          easing: "ease-out"
        });
      this.toc.style.opacity = "1";
      this.toc.style.borderInlineStart = "1px solid var(--sl-color-hairline)";
    }
  }

  connectedCallback() {    
    this.focusedButton.addEventListener("click", () => {
      if (this.focusedMode) {
        // if focused mode is on, close it
        this.deactivate();
      } else {
        // Otherwise, activate it
        this.activate();
      }
    });

    window.addEventListener("resize", this.handleResize);

    /* Allow the opacity to be change for the toc, if the screen is greater that
     * a tablet i.e a PC */
    this.toc?.addEventListener("mouseover", () => {
      if (this.focusedMode && this.isPC)
        this.toc.style.opacity = "1";
    });

    this.toc?.addEventListener("mouseout", () => {
      if (this.focusedMode && this.isPC)
        this.toc.style.opacity = ".2";
    });
  }

  disconnectedCallback() {
    // Clean up: removing global event listeners
    window.removeEventListener("resize", this.handleResize);
  }
}
customElements.define('focused-mode', FocusedMode);
</script>
